#!/usr/bin/env crystal
# noir/scripts/generate_supported_docs.cr
# Generate supported documentation pages directly from NoirTechs::TECHS.
#
# No binary build required — requires the techs module directly.
#
# Generates (auto-injected after <!-- AUTOGENERATED--> marker):
#   - docs/content/usage/supported/language_and_frameworks/*.md
#   - docs/content/usage/supported/specification/*.md
#
# Usage:
#   crystal run scripts/generate_supported_docs.cr -- [options]
#   just docs-supported
#
# Examples:
#   crystal run scripts/generate_supported_docs.cr
#   crystal run scripts/generate_supported_docs.cr -- --dry-run
#   crystal run scripts/generate_supported_docs.cr -- -q
#
# Exit codes:
#   0 - Success
#   2 - Invalid options

require "option_parser"
require "../src/techs/techs"

AUTOGEN_MARKER = "<!-- AUTOGENERATED-->"

SPEC_FRIENDLY_NAMES = {
  "har"     => "HAR",
  "oas2"    => "OpenAPI 2.0 (Swagger)",
  "oas3"    => "OpenAPI 3.0",
  "graphql" => "GraphQL",
  "raml"    => "RAML",
  "postman" => "Postman Collection",
}

def check(b : Bool) : String
  b ? "☑️" : "✗"
end

def project_root : String
  script_dir = File.dirname(File.expand_path(__FILE__))
  File.basename(script_dir) == "scripts" ? File.expand_path("..", script_dir) : script_dir
end

def ensure_parent_dir(path : String)
  dir = File.dirname(path)
  Dir.mkdir_p(dir) unless Dir.exists?(dir)
end

# Render supported features as markdown table cells
def feature_cells(supported : JSON::Any) : String
  h = supported.as_h
  params = h["params"]?.try(&.as_h) || {} of String => JSON::Any

  [
    h["endpoint"]?.try(&.as_bool) || false,
    h["method"]?.try(&.as_bool) || false,
    params["query"]?.try(&.as_bool) || false,
    params["path"]?.try(&.as_bool) || false,
    params["body"]?.try(&.as_bool) || false,
    params["header"]?.try(&.as_bool) || false,
    params["cookie"]?.try(&.as_bool) || false,
    h["static_path"]?.try(&.as_bool) || false,
    h["websocket"]?.try(&.as_bool) || false,
  ].map { |v| check(v) }.join(" | ")
end

# Generate language/framework tables grouped by language
def generate_language_tables(data : JSON::Any) : String
  by_language = Hash(String, Array({name: String, cells: String})).new { |h, k| h[k] = [] of {name: String, cells: String} }

  data.as_h.each do |_key, info|
    h = info.as_h
    next unless h.has_key?("language")

    language = h["language"].as_s
    framework = h["framework"]?.try(&.as_s) || ""
    framework = "Pure" if framework.empty?
    by_language[language] << {name: framework, cells: feature_cells(h["supported"])}
  end

  io = IO::Memory.new
  by_language.keys.sort!.each do |lang|
    entries = by_language[lang].sort_by { |e| e[:name] }
    io << "## #{lang}\n\n"
    io << "| Framework | endpoint | method | query | path | body | header | cookie | static_path | websocket |\n"
    io << "|-----------|----------|--------|-------|------|------|--------|--------|-------------|-----------|"
    io << "\n"
    entries.each do |e|
      io << "| #{e[:name]} | #{e[:cells]} |\n"
    end
    io << "\n"
  end

  io.to_s
end

# Generate specification table
def generate_spec_table(data : JSON::Any) : String
  specs = [] of {name: String, format: String, cells: String}

  data.as_h.each do |key, info|
    h = info.as_h
    next if h.has_key?("language")
    next unless h.has_key?("format")

    name = SPEC_FRIENDLY_NAMES[key]? || key.gsub("_", " ").split.map(&.capitalize).join(" ")
    formats = h["format"].as_a.map(&.as_s)
    cells = feature_cells(h["supported"])

    formats.each do |fmt|
      specs << {name: name, format: fmt, cells: cells}
    end
  end

  specs.sort_by! { |e| e[:name] }

  io = IO::Memory.new
  io << "| Specification | Format | endpoint | method | query | path | body | header | cookie | static_path | websocket |\n"
  io << "|---|---|---|---|---|---|---|---|---|---|---|\n"
  specs.each do |e|
    io << "| #{e[:name]} | #{e[:format]} | #{e[:cells]} |\n"
  end

  io.to_s
end

# Inject generated content after AUTOGEN_MARKER in all .md files in a directory
def inject_autogen(dir : String, content : String, dry_run : Bool) : Array(String)
  updated = [] of String

  Dir.glob(File.join(dir, "*.md")).each do |path|
    file_content = File.read(path)
    parts = file_content.split(AUTOGEN_MARKER, 2)
    next unless parts.size == 2

    new_content = parts[0] + AUTOGEN_MARKER + "\n\n" + content
    new_content += "\n" unless new_content.ends_with?("\n")

    unless dry_run
      ensure_parent_dir(path)
      File.write(path, new_content)
    end
    updated << path
  end

  updated
end

# --------------------
# CLI and entry point
# --------------------

quiet = false
dry_run = false
show_help = false

parser = OptionParser.new do |p|
  p.banner = "Usage: crystal run scripts/generate_supported_docs.cr -- [options]"
  p.on("-q", "--quiet", "Quiet mode (suppress output messages)") { quiet = true }
  p.on("--dry-run", "Preview changes without writing files") { dry_run = true }
  p.on("-h", "--help", "Show help") { show_help = true }
end

begin
  parser.parse
rescue ex : OptionParser::Exception
  STDERR.puts ex.message
  STDERR.puts
  STDERR.puts parser
  exit 2
end

if show_help
  puts parser
  puts
  puts "Description:"
  puts "  Generates supported documentation pages from NoirTechs::TECHS."
  puts "  No binary build required."
  puts
  puts "Generates:"
  puts "  - docs/content/usage/supported/language_and_frameworks/*.md"
  puts "  - docs/content/usage/supported/specification/*.md"
  puts
  puts "Examples:"
  puts "  crystal run scripts/generate_supported_docs.cr"
  puts "  crystal run scripts/generate_supported_docs.cr -- --dry-run"
  puts "  crystal run scripts/generate_supported_docs.cr -- -q"
  puts "  just docs-supported"
  exit 0
end

root = project_root
data = JSON.parse(NoirTechs::TECHS.to_json)
docs_dir = File.join(root, "docs", "content", "usage", "supported")

# Generate and inject language/framework tables
lang_tables = generate_language_tables(data)
updated = inject_autogen(File.join(docs_dir, "language_and_frameworks"), lang_tables, dry_run)
unless quiet
  prefix = dry_run ? "Would update" : "Updated"
  updated.each { |p| puts "#{prefix}: #{p}" }
end

# Generate and inject specification table
spec_table = generate_spec_table(data)
updated = inject_autogen(File.join(docs_dir, "specification"), spec_table, dry_run)
unless quiet
  prefix = dry_run ? "Would update" : "Updated"
  updated.each { |p| puts "#{prefix}: #{p}" }
end
